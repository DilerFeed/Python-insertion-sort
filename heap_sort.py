import random
import time

def main():
    # Заповнюємо масив для сортування
    type = 2
    N = int(input("Введіть кількість елементів масиву: "))
    array = []
    # Випадково (середній і найгірший випадок пірамідального сортування)
    if type == 1:
        for i in range(N):
            array.append(random.randint(0,(N**2)))
    # Заповнення однаковими елементами (найкращий випадок пірамідального сортування)
    elif type == 2:
        rnd_number = random.randint(0,(N**2))
        for i in range(N):
            array.append(rnd_number)

    """
    print("-----------------")
    print("Початковий масив:")
    print(array)
    """
    # Функція пірамідального сортування
    def heapSort(li):
        # Функція для просіювання вниз на одному вузлі дерева (k – поточний вузол, n – індекс останнього вузла в дереві)
        def downHeap(li, k, n):
            # Зберігаємо знаяення поточного вузла
            new_elem = li[k]
            # Дивимося на дочірні вузли поточного вузла і вибираємо той, який має більше значення
            while k <= n/2:
                child = 2*k
                # Якщо значення дочірнього вузла більше, ми змінюємо місцями значення і продовжуємо просівати вниз дочірнім вузлом.
                if child < n and li[child] < li[child+1]:
                    child += 1
                # Якщо поточний вузол більший або дорівнює максимальному з його дочірніх вузлів, ми знаходимося в правильному місці в купі
                if new_elem >= li[child]:
                    break
                li[k] = li[child]
                k = child
            # Зберігаємо нове значення вузла у його нове місце
            li[k] = new_elem

        # Визначаємо розмір списку
        size = len(li)
        # Проходимо по списку та викликаємо функцію downHeap() для кожного елемента, починаючи з середини списку.
        # Це встановить кожен елемент у правильному місці у купі.
        for i in range(round(size/2-1),-1,-1):
            downHeap(li, i, size-1)
        # Проходимо за списком у зворотному порядку, починаючи з кінця, і міняємо місцями перший елемент (найбільший) із значенням останнього елемента у списку.
        # Потім ми викликаємо downHeap() для першого елемента, щоб встановити його в правильне місце в купі.
        # Ми продовжуємо робити це доти, доки список не буде відсортовано.
        for i in range(size-1,0,-1):
            temp = li[i]
            li[i] = li[0]
            li[0] = temp
            downHeap(li, 0, i-1)
        return li

    ref_time = time.perf_counter()
    heapSort(array)

    # Вивести дані по часу сортування всіх елементів
    cur_time = time.perf_counter()
    print(f"Відсортовано {N} елементів за {cur_time - ref_time} секунд!")

    """
    print("Відсортований масив:")
    print(array)
    """

if __name__ == "__main__":
    main()